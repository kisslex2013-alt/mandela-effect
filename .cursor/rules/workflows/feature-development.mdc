---
description: –ü–æ—à–∞–≥–æ–≤—ã–π workflow –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –Ω–æ–≤—ã—Ö —Ñ–∏—á –æ—Ç –∏–¥–µ–∏ –¥–æ production
alwaysApply: false
---

# Feature Development Workflow

## –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å

–ê–∫—Ç–∏–≤–∏—Ä—É–π —ç—Ç–æ—Ç workflow –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≥–æ–≤–æ—Ä–∏—Ç:

- "–î–æ–±–∞–≤—å –Ω–æ–≤—É—é —Ñ–∏—á—É [–æ–ø–∏—Å–∞–Ω–∏–µ]"
- "–†–µ–∞–ª–∏–∑—É–π [—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å]"
- "–°–æ–∑–¥–∞–π [–∫–æ–º–ø–æ–Ω–µ–Ω—Ç/—Å—Ç—Ä–∞–Ω–∏—Ü—É/–º–æ–¥—É–ª—å]"
- "–ù—É–∂–Ω–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å [—á—Ç–æ-—Ç–æ –¥–µ–ª–∞—Ç—å]"

**–ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–ê–Ø –ê–ö–¢–ò–í–ê–¶–ò–Ø:**
–ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç—Ä–∏–≥–≥–µ—Ä–Ω—ã–µ —Ñ—Ä–∞–∑—ã ("–ø–æ –ø—Ä–∞–≤–∏–ª–∞–º", "—Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ", "—Å –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º", "workflow"), –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û:
1. ‚úÖ –°–æ–∑–¥–∞—Ç—å –ø–ª–∞–Ω —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
2. ‚úÖ –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á–∏ –≤ Beads (—ç–ø–∏–∫ + –ø–æ–¥–∑–∞–¥–∞—á–∏)
3. ‚úÖ –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –∫–∞—á–µ—Å—Ç–≤–∞ (`npm run quality:check`)
4. ‚úÖ –°–ª–µ–¥–æ–≤–∞—Ç—å –≤—Å–µ–º —ç—Ç–∞–ø–∞–º workflow
5. ‚úÖ –ó–∞–ø–∏—Å–∞—Ç—å —É—Ä–æ–∫–∏ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è

## –≠—Ç–∞–ø—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∏—á–∏

### –≠—Ç–∞–ø 0: –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞–Ω–∞ –∏ –∑–∞–¥–∞—á –≤ Beads (–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û)

**–ü–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ä–∞–±–æ—Ç—ã:**

1. **–°–æ–∑–¥–∞–π –∑–∞–¥–∞—á–∏ –≤ Beads** (–¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è)
2. **–°–æ–∑–¥–∞–π –¥–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω** (—Ç–µ–∫—Å—Ç–æ–≤—ã–π)

#### –®–∞–≥ 1: –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞—á –≤ Beads

**–í—Å–µ–≥–¥–∞ —Å–æ–∑–¥–∞–≤–∞–π –∑–∞–¥–∞—á–∏ –≤ Beads –¥–ª—è –Ω–æ–≤—ã—Ö —Ñ–∏—á:**

```bash
# 1. –°–æ–∑–¥–∞—Ç—å —ç–ø–∏–∫ –¥–ª—è —Ñ–∏—á–∏
EPIC_ID=$(bd create "[–ù–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏—á–∏]" -t epic -p 1 --json | jq -r '.id')

# 2. –°–æ–∑–¥–∞—Ç—å –ø–æ–¥–∑–∞–¥–∞—á–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —ç—Ç–∞–ø–∞
TASK_ANALYSIS=$(bd create "–ê–Ω–∞–ª–∏–∑ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ" -t task -p 1 --json | jq -r '.id')
TASK_STRUCTURE=$(bd create "–°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ñ–∞–π–ª–æ–≤" -t task -p 1 --json | jq -r '.id')
TASK_TYPES=$(bd create "–°–æ–∑–¥–∞–Ω–∏–µ TypeScript —Ç–∏–ø–æ–≤" -t task -p 1 --json | jq -r '.id')
TASK_STORE=$(bd create "–°–æ–∑–¥–∞–Ω–∏–µ Zustand store" -t task -p 1 --json | jq -r '.id')
TASK_COMPONENTS=$(bd create "–°–æ–∑–¥–∞–Ω–∏–µ React –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤" -t task -p 1 --json | jq -r '.id')
TASK_TESTS=$(bd create "–ù–∞–ø–∏—Å–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤" -t task -p 2 --json | jq -r '.id')
TASK_DOCS=$(bd create "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏" -t task -p 2 --json | jq -r '.id')

# 3. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è)
bd dep add $TASK_STRUCTURE $TASK_ANALYSIS --type blocks
bd dep add $TASK_TYPES $TASK_STRUCTURE --type blocks
bd dep add $TASK_STORE $TASK_TYPES --type blocks
bd dep add $TASK_COMPONENTS $TASK_STORE --type blocks
bd dep add $TASK_TESTS $TASK_COMPONENTS --type blocks
bd dep add $TASK_DOCS $TASK_TESTS --type blocks

# 4. –ü–æ–∫–∞–∑–∞—Ç—å –ø–ª–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
bd dep tree $EPIC_ID
bd ready --json
```

**–ù–∞—á–∞—Ç—å —Å –ø–µ—Ä–≤–æ–π –≥–æ—Ç–æ–≤–æ–π –∑–∞–¥–∞—á–∏:**

```bash
# –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–≤—É—é –≥–æ—Ç–æ–≤—É—é –∑–∞–¥–∞—á—É
READY_TASK=$(bd ready --limit 1 --json | jq -r '.[0].id')

# –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å
bd update $READY_TASK --status in_progress

echo "–ù–∞—á–∏–Ω–∞–µ–º —Å –∑–∞–¥–∞—á–∏: $READY_TASK"
```

**–ü—Ä–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–∏ –±–∞–≥–∞ –∏–ª–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç—ã:**

```bash
# –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É-–±–∞–≥
BUG_ID=$(bd create "–ë–∞–≥: [–æ–ø–∏—Å–∞–Ω–∏–µ]" -t bug -p 0 --json | jq -r '.id')

# –ò–ª–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∑–∞–¥–∞—á—É
EXTRA_TASK=$(bd create "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: [–æ–ø–∏—Å–∞–Ω–∏–µ]" -t task -p 2 --json | jq -r '.id')

# –°–≤—è–∑–∞—Ç—å —Å —Ç–µ–∫—É—â–µ–π –∑–∞–¥–∞—á–µ–π
bd dep add $BUG_ID $CURRENT_TASK --type discovered-from
```

**–ü—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏:**

```bash
# –ó–∞–∫—Ä—ã—Ç—å –∑–∞–¥–∞—á—É
bd close $TASK_ID --reason "–ì–æ—Ç–æ–≤–æ: [–∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ]"

# –ü–æ–∫–∞–∑–∞—Ç—å —Å–ª–µ–¥—É—é—â—É—é –≥–æ—Ç–æ–≤—É—é –∑–∞–¥–∞—á—É
bd ready --json
```

#### –®–∞–≥ 2: –°–æ–∑–¥–∞–Ω–∏–µ –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –ø–ª–∞–Ω–∞ (—Ç–µ–∫—Å—Ç–æ–≤—ã–π)

**–ü–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ä–∞–±–æ—Ç—ã —Å–æ–∑–¥–∞–π –¥–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω:**

```markdown
## üìã –ü–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: [–ù–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏—á–∏]

### –ê–Ω–∞–ª–∏–∑
- **–¶–µ–ª—å:** [–ß—Ç–æ –Ω—É–∂–Ω–æ –¥–æ—Å—Ç–∏—á—å]
- **Scope:** 
  - ‚úÖ –í–∫–ª—é—á–µ–Ω–æ: [—á—Ç–æ –¥–µ–ª–∞–µ–º]
  - ‚ùå –ù–µ –≤–∫–ª—é—á–µ–Ω–æ: [—á—Ç–æ –ù–ï –¥–µ–ª–∞–µ–º]
- **–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:** [–û—Ç —á–µ–≥–æ –∑–∞–≤–∏—Å–∏—Ç]
- **–†–∏—Å–∫–∏:** [–ß—Ç–æ –º–æ–∂–µ—Ç –ø–æ–π—Ç–∏ –Ω–µ —Ç–∞–∫]

### –®–∞–≥–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

#### –®–∞–≥ 1: [–ù–∞–∑–≤–∞–Ω–∏–µ]
- **–§–∞–π–ª—ã:** [—Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤]
- **–î–µ–π—Å—Ç–≤–∏—è:** [—á—Ç–æ –¥–µ–ª–∞–µ–º]
- **–ü—Ä–æ–≤–µ—Ä–∫–∞:** [–∫–∞–∫ –ø—Ä–æ–≤–µ—Ä–∏–º]

#### –®–∞–≥ 2: [–ù–∞–∑–≤–∞–Ω–∏–µ]
...

### Edge Cases
- [ ] –ß—Ç–æ –µ—Å–ª–∏ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö?
- [ ] –ß—Ç–æ –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ —Å–µ—Ç–∏?
- [ ] –ß—Ç–æ –µ—Å–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞?

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
- [ ] Unit —Ç–µ—Å—Ç—ã
- [ ] –†—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
- [ ] –ü—Ä–æ–≤–µ—Ä–∫–∞ edge cases
```

**–ü—Ä–∞–≤–∏–ª–æ:** –ü–ª–∞–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω –î–û –Ω–∞—á–∞–ª–∞ –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∫–æ–¥–∞. –ï—Å–ª–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–∞–±–æ—Ç—ã –ø–ª–∞–Ω –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å - –æ–±–Ω–æ–≤–∏ –µ–≥–æ –∏ –æ–±—ä—è—Å–Ω–∏ –ø—Ä–∏—á–∏–Ω—É.

**–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Beads:**
- –ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞–Ω–∞ –ø–æ–∫–∞–∂–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –¥–µ—Ä–µ–≤–æ –∑–∞–¥–∞—á: `bd dep tree $EPIC_ID`
- –ù–∞—á–Ω–∏ —Å –ø–µ—Ä–≤–æ–π –≥–æ—Ç–æ–≤–æ–π –∑–∞–¥–∞—á–∏: `bd ready --limit 1 --json`
- –û–±–Ω–æ–≤–ª—è–π —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á –ø–æ –º–µ—Ä–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: `bd update $TASK_ID --status in_progress`
- –ü—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —à–∞–≥–∞: `bd close $TASK_ID --reason "–ì–æ—Ç–æ–≤–æ"`

### –≠—Ç–∞–ø 1: –ê–Ω–∞–ª–∏–∑ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ (5-10 –º–∏–Ω—É—Ç)

**–û–±–Ω–æ–≤–∏ —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –≤ Beads:**

```bash
# –ï—Å–ª–∏ –µ—â–µ –Ω–µ –æ–±–Ω–æ–≤–ª–µ–Ω, –æ–±–Ω–æ–≤–∏ —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –∞–Ω–∞–ª–∏–∑–∞
bd update $TASK_ANALYSIS --status in_progress
```

**–ó–∞–¥–∞–π —É—Ç–æ—á–Ω—è—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã:**

```text
1. –ö–∞–∫–∞—è –æ—Å–Ω–æ–≤–Ω–∞—è —Ü–µ–ª—å —Ñ–∏—á–∏?
2. –ö—Ç–æ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å? (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏/–∞–¥–º–∏–Ω—ã/–≤—Å–µ)
3. –ï—Å—Ç—å –ª–∏ UI/UX —Ä–µ—Ñ–µ—Ä–µ–Ω—Å—ã –∏–ª–∏ –º–∞–∫–µ—Ç—ã?
4. –ö–∞–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –Ω—É–∂–Ω—ã? (–æ—Ç–∫—É–¥–∞ –±—Ä–∞—Ç—å?)
5. –ù—É–∂–Ω–∞ –ª–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è/–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è?
6. –ï—Å—Ç—å –ª–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –¥—Ä—É–≥–∏—Ö —Ñ–∏—á?
7. –ú–æ–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è –Ω—É–∂–Ω–∞?
```

**–°–æ–∑–¥–∞–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ:**

```markdown
## –§–∏—á–∞: [–ù–∞–∑–≤–∞–Ω–∏–µ]

### –¶–µ–ª—å
[–ß—Ç–æ —Ä–µ—à–∞–µ—Ç, –∑–∞—á–µ–º –Ω—É–∂–Ω–æ]

### Scope
- ‚úÖ –í–∫–ª—é—á–µ–Ω–æ: [—á—Ç–æ –¥–µ–ª–∞–µ–º]
- ‚ùå –ù–µ –≤–∫–ª—é—á–µ–Ω–æ: [—á—Ç–æ –ù–ï –¥–µ–ª–∞–µ–º –≤ —ç—Ç–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏]

### –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
1. Frontend: [—Å–ø–∏—Å–æ–∫ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤]
2. Backend: [—Å–ø–∏—Å–æ–∫ API endpoints]
3. State: [–∫–∞–∫–∏–µ stores –∑–∞—Ç—Ä–æ–Ω—É—Ç—ã]
4. Database: [–Ω–æ–≤—ã–µ —Ç–∞–±–ª–∏—Ü—ã/–ø–æ–ª—è]

### User Flow
1. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å...
2. –°–∏—Å—Ç–µ–º–∞...
3. –†–µ–∑—É–ª—å—Ç–∞—Ç...

### Edge Cases
- –ß—Ç–æ –µ—Å–ª–∏ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö?
- –ß—Ç–æ –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ —Å–µ—Ç–∏?
- –ß—Ç–æ –µ—Å–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞?
```

### –≠—Ç–∞–ø 2: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–æ–≤ (2 –º–∏–Ω—É—Ç—ã)

**–°–æ–∑–¥–∞–π —Ñ–∞–π–ª–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É:**

```text
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ FeatureName/
‚îÇ       ‚îú‚îÄ‚îÄ FeatureName.tsx          # –ì–ª–∞–≤–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
‚îÇ       ‚îú‚îÄ‚îÄ FeatureNameForm.tsx      # –§–æ—Ä–º–∞ (–µ—Å–ª–∏ –Ω—É–∂–Ω–∞)
‚îÇ       ‚îú‚îÄ‚îÄ FeatureNameList.tsx      # –°–ø–∏—Å–æ–∫ (–µ—Å–ª–∏ –Ω—É–∂–µ–Ω)
‚îÇ       ‚îî‚îÄ‚îÄ FeatureName.test.tsx     # –¢–µ—Å—Ç—ã
‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îî‚îÄ‚îÄ featureStore.ts              # Zustand store
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îî‚îÄ‚îÄ feature/
‚îÇ       ‚îî‚îÄ‚îÄ route.ts                 # API endpoints
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ feature.ts                   # TypeScript types
```

**–û–ø—Ä–µ–¥–µ–ª–∏ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–≤—ã–º –¥–µ–ª–æ–º:**

```typescript
// types/feature.ts
export interface Feature {
  id: string
  title: string
  description: string
  createdAt: Date
  updatedAt: Date
  userId: string
}

export interface CreateFeatureInput {
  title: string
  description: string
}

export interface UpdateFeatureInput extends Partial<CreateFeatureInput> {
  id: string
}
```

### –≠—Ç–∞–ø 3: Backend —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞ (–µ—Å–ª–∏ –Ω—É–∂–µ–Ω)

**–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å:**

1. **–°–æ–∑–¥–∞–π API route** (–Ω–∞—á–Ω–∏ —Å —ç—Ç–æ–≥–æ!)

```typescript
// app/api/features/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'

const CreateFeatureSchema = z.object({
  title: z.string().min(3).max(100),
  description: z.string().min(10).max(500)
})

export async function GET(request: NextRequest) {
  try {
    // 1. –ü—Ä–æ–≤–µ—Ä—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
    const user = await verifyAuth(request)
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    
    // 2. –ü–æ–ª—É—á–∏ –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
    const features = await prisma.feature.findMany({
      where: { userId: user.id },
      orderBy: { createdAt: 'desc' }
    })
    
    // 3. –í–µ—Ä–Ω–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    return NextResponse.json({ features })
    
  } catch (error) {
    console.error('GET /api/features error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const user = await verifyAuth(request)
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    
    const body = await request.json()
    const validated = CreateFeatureSchema.parse(body)
    
    const feature = await prisma.feature.create({
      data: {
        ...validated,
        userId: user.id
      }
    })
    
    return NextResponse.json({ feature }, { status: 201 })
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      )
    }
    
    console.error('POST /api/features error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

1. **–ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–π API –≤—Ä—É—á–Ω—É—é** (—á–µ—Ä–µ–∑ Postman/Thunder Client)

```bash
# GET request
curl http://localhost:3000/api/features \
  -H "Authorization: Bearer YOUR_TOKEN"

# POST request  
curl -X POST http://localhost:3000/api/features \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{"title":"Test","description":"Test description"}'
```

1. **–ù–∞–ø–∏—à–∏ unit —Ç–µ—Å—Ç—ã –¥–ª—è API** (–ø–µ—Ä–µ–¥ frontend!)

```typescript
// app/api/features/route.test.ts
import { describe, it, expect } from 'vitest'
import { GET, POST } from './route'

describe('Features API', () => {
  it('GET –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ñ–∏—á', async () => {
    const request = createMockRequest({ userId: 'test-user' })
    const response = await GET(request)
    const data = await response.json()
    
    expect(response.status).toBe(200)
    expect(data.features).toBeInstanceOf(Array)
  })
  
  it('POST —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Ñ–∏—á—É', async () => {
    const request = createMockRequest({
      userId: 'test-user',
      body: { title: 'Test', description: 'Test description' }
    })
    const response = await POST(request)
    const data = await response.json()
    
    expect(response.status).toBe(201)
    expect(data.feature.title).toBe('Test')
  })
})
```

### –≠—Ç–∞–ø 4: State management (Zustand store)

```typescript
// store/featureStore.ts
import { create } from 'zustand'
import type { Feature, CreateFeatureInput } from '@/types/feature'

interface FeatureState {
  features: Feature[]
  isLoading: boolean
  error: string | null
  
  // Actions
  fetchFeatures: () => Promise<void>
  createFeature: (input: CreateFeatureInput) => Promise<Feature>
  updateFeature: (id: string, input: Partial<CreateFeatureInput>) => Promise<void>
  deleteFeature: (id: string) => Promise<void>
}

export const useFeatureStore = create<FeatureState>((set, get) => ({
  features: [],
  isLoading: false,
  error: null,
  
  fetchFeatures: async () => {
    set({ isLoading: true, error: null })
    
    try {
      const response = await fetch('/api/features')
      
      if (!response.ok) {
        throw new Error('Failed to fetch features')
      }
      
      const { features } = await response.json()
      set({ features, isLoading: false })
      
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Unknown error',
        isLoading: false 
      })
    }
  },
  
  createFeature: async (input) => {
    set({ isLoading: true, error: null })
    
    try {
      const response = await fetch('/api/features', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(input)
      })
      
      if (!response.ok) {
        throw new Error('Failed to create feature')
      }
      
      const { feature } = await response.json()
      
      set((state) => ({
        features: [feature, ...state.features],
        isLoading: false
      }))
      
      return feature
      
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Unknown error',
        isLoading: false 
      })
      throw error
    }
  },
  
  updateFeature: async (id, input) => {
    try {
      const response = await fetch(`/api/features/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(input)
      })
      
      if (!response.ok) {
        throw new Error('Failed to update feature')
      }
      
      const { feature } = await response.json()
      
      set((state) => ({
        features: state.features.map((f) => 
          f.id === id ? feature : f
        )
      }))
      
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Unknown error' })
      throw error
    }
  },
  
  deleteFeature: async (id) => {
    try {
      const response = await fetch(`/api/features/${id}`, {
        method: 'DELETE'
      })
      
      if (!response.ok) {
        throw new Error('Failed to delete feature')
      }
      
      set((state) => ({
        features: state.features.filter((f) => f.id !== id)
      }))
      
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Unknown error' })
      throw error
    }
  }
}))
```

### –≠—Ç–∞–ø 5: Frontend –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã

**–ü–æ—Ä—è–¥–æ–∫ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏:**

1. **–ü—Ä–æ—Å—Ç–æ–π UI –ø–µ—Ä–≤—ã–º** (–±–µ–∑ –ª–æ–≥–∏–∫–∏)
2. **–î–æ–±–∞–≤—å state –∏ handlers**
3. **–ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–π —Å–æ store**
4. **–î–æ–±–∞–≤—å loading/error states**
5. **–ü–æ–ª–∏—Ä—É–π UI –∏ –∞–Ω–∏–º–∞—Ü–∏–∏**

```typescript
// components/FeatureName/FeatureName.tsx
'use client'

import { useEffect } from 'react'
import { useFeatureStore } from '@/store/featureStore'
import { FeatureNameForm } from './FeatureNameForm'
import { FeatureNameList } from './FeatureNameList'

export function FeatureName() {
  const { features, isLoading, error, fetchFeatures } = useFeatureStore()
  
  // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
  useEffect(() => {
    fetchFeatures()
  }, [fetchFeatures])
  
  // Loading state
  if (isLoading && features.length === 0) {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="animate-spin h-8 w-8 border-4 border-blue-500 border-t-transparent rounded-full" />
      </div>
    )
  }
  
  // Error state
  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
        <p className="text-red-800">–û—à–∏–±–∫–∞: {error}</p>
        <button 
          onClick={fetchFeatures}
          className="mt-2 text-sm text-red-600 hover:text-red-800"
        >
          –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞
        </button>
      </div>
    )
  }
  
  // Main content
  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold">Features</h1>
        <p className="text-gray-600 mt-2">
          Manage your features here
        </p>
      </div>
      
      <FeatureNameForm />
      <FeatureNameList features={features} />
    </div>
  )
}
```

```typescript
// components/FeatureName/FeatureNameForm.tsx
'use client'

import { useState } from 'react'
import { useFeatureStore } from '@/store/featureStore'
import { motion } from 'framer-motion'

export function FeatureNameForm() {
  const createFeature = useFeatureStore((state) => state.createFeature)
  const [title, setTitle] = useState('')
  const [description, setDescription] = useState('')
  const [isSubmitting, setIsSubmitting] = useState(false)
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!title.trim() || !description.trim()) return
    
    setIsSubmitting(true)
    
    try {
      await createFeature({ title, description })
      
      // Reset form
      setTitle('')
      setDescription('')
      
    } catch (error) {
      console.error('Failed to create feature:', error)
    } finally {
      setIsSubmitting(false)
    }
  }
  
  return (
    <motion.form
      onSubmit={handleSubmit}
      className="bg-white p-6 rounded-lg shadow-sm border border-gray-200"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
    >
      <h2 className="text-xl font-semibold mb-4">Create New Feature</h2>
      
      <div className="space-y-4">
        <div>
          <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-1">
            Title
          </label>
          <input
            id="title"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Enter feature title"
            required
            disabled={isSubmitting}
          />
        </div>
        
        <div>
          <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-1">
            Description
          </label>
          <textarea
            id="description"
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
            placeholder="Enter feature description"
            rows={4}
            required
            disabled={isSubmitting}
          />
        </div>
        
        <button
          type="submit"
          disabled={isSubmitting || !title.trim() || !description.trim()}
          className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
        >
          {isSubmitting ? 'Creating...' : 'Create Feature'}
        </button>
      </div>
    </motion.form>
  )
}
```

### –≠—Ç–∞–ø 6: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–´

```typescript
// components/FeatureName/FeatureName.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { FeatureName } from './FeatureName'
import { useFeatureStore } from '@/store/featureStore'

// Mock store
vi.mock('@/store/featureStore')

describe('FeatureName', () => {
  beforeEach(() => {
    vi.mocked(useFeatureStore).mockReturnValue({
      features: [],
      isLoading: false,
      error: null,
      fetchFeatures: vi.fn(),
      createFeature: vi.fn(),
      updateFeature: vi.fn(),
      deleteFeature: vi.fn()
    })
  })
  
  it('–∑–∞–≥—Ä—É–∂–∞–µ—Ç –∏ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç features', async () => {
    const mockFeatures = [
      { id: '1', title: 'Feature 1', description: 'Desc 1', createdAt: new Date(), updatedAt: new Date(), userId: '1' }
    ]
    
    vi.mocked(useFeatureStore).mockReturnValue({
      features: mockFeatures,
      isLoading: false,
      error: null,
      fetchFeatures: vi.fn(),
      createFeature: vi.fn(),
      updateFeature: vi.fn(),
      deleteFeature: vi.fn()
    })
    
    render(<FeatureName />)
    
    expect(screen.getByText('Feature 1')).toBeInTheDocument()
  })
  
  it('–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç loader –≤–æ –≤—Ä–µ–º—è –∑–∞–≥—Ä—É–∑–∫–∏', () => {
    vi.mocked(useFeatureStore).mockReturnValue({
      features: [],
      isLoading: true,
      error: null,
      fetchFeatures: vi.fn(),
      createFeature: vi.fn(),
      updateFeature: vi.fn(),
      deleteFeature: vi.fn()
    })
    
    render(<FeatureName />)
    
    expect(screen.getByRole('status')).toBeInTheDocument() // Spinner
  })
  
  it('–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –æ—à–∏–±–∫—É –ø—Ä–∏ –Ω–µ—É–¥–∞—á–µ', () => {
    vi.mocked(useFeatureStore).mockReturnValue({
      features: [],
      isLoading: false,
      error: 'Failed to load features',
      fetchFeatures: vi.fn(),
      createFeature: vi.fn(),
      updateFeature: vi.fn(),
      deleteFeature: vi.fn()
    })
    
    render(<FeatureName />)
    
    expect(screen.getByText(/failed to load features/i)).toBeInTheDocument()
  })
  
  it('—Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é feature —á–µ—Ä–µ–∑ —Ñ–æ—Ä–º—É', async () => {
    const mockCreateFeature = vi.fn()
    
    vi.mocked(useFeatureStore).mockReturnValue({
      features: [],
      isLoading: false,
      error: null,
      fetchFeatures: vi.fn(),
      createFeature: mockCreateFeature,
      updateFeature: vi.fn(),
      deleteFeature: vi.fn()
    })
    
    render(<FeatureName />)
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ñ–æ—Ä–º—É
    fireEvent.change(screen.getByLabelText(/title/i), {
      target: { value: 'New Feature' }
    })
    fireEvent.change(screen.getByLabelText(/description/i), {
      target: { value: 'New feature description' }
    })
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º
    fireEvent.click(screen.getByRole('button', { name: /create feature/i }))
    
    await waitFor(() => {
      expect(mockCreateFeature).toHaveBeenCalledWith({
        title: 'New Feature',
        description: 'New feature description'
      })
    })
  })
})
