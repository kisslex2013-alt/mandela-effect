# Критический баг: Зависание UI при голосовании

## Описание проблемы

**Симптомы:**
- Проект часто зависает при голосовании
- Интерфейс блокируется в случайный момент
- Помогает только открытие в новой вкладке
- Проблема воспроизводится не всегда, но достаточно часто

**Воспроизведение:**
1. Открыть страницу каталога (`/catalog`) или страницу эффекта (`/effect/[id]`)
2. Начать голосовать быстро и часто (2-5 голосов подряд с интервалом 1-3 секунды)
3. В какой-то момент интерфейс полностью блокируется
4. Помогает только открытие новой вкладки

## История отладки

### Первоначальные гипотезы

#### H1: Множественные одновременные серверные запросы блокируют UI
**Статус:** REJECTED
**Доказательства из логов:**
- `activeRequests:1` в логах - только один запрос одновременно
- Защита от множественных вызовов работает корректно

#### H2: Множественные setState вызывают каскадные re-renders
**Статус:** PARTIALLY CONFIRMED
**Доказательства из логов:**
- `votesStore.set` вызывается дважды для одного эффекта
- `localStorage SET` выполняется быстро (~0.3-0.5ms)

#### H3: Race conditions между голосованием, навигацией и обновлением состояния
**Статус:** REJECTED
**Доказательства из логов:**
- DB операции выполняются нормально (290-300ms)
- Нет признаков race conditions

#### H4: Долгие синхронные операции на главном потоке
**Статус:** REJECTED
**Доказательства из логов:**
- Защита от множественных вызовов работает
- Все операции асинхронные

#### H5: Частые вызовы `checkStatus`/`incrementVotes` в `RealityContext`
**Статус:** CONFIRMED (частично)
**Доказательства из логов:**
- `checkStatus` вызывался слишком часто, блокируя UI
- `getUserVotedEffects` занимал ~743ms

**Исправление:**
- Увеличен debounce для `checkStatus` с 1s до 3s
- Добавлен `startTransition` для `setVoteCount` и `setIsUnlocked` в `RealityContext.tsx`

#### H6: `localStorage` блокирует из-за частых обновлений
**Статус:** PARTIALLY CONFIRMED
**Доказательства из логов:**
- Множественные `votesStore.set` вызовы для одного эффекта
- `localStorage SET` выполняется быстро, но вызывается часто

#### H7: Каскадные re-renders при `votes-updated` событии
**Статус:** CONFIRMED
**Доказательства из логов:**
- `loadVotes` в `CatalogClient.tsx` вызывался дважды одновременно (строки 64-65, 571-572)
- `loadVotes` занимал ~142ms и вызывался слишком часто
- `handleUpdate` в `EffectCard.tsx` вызывал множественные синхронные re-renders

**Исправления:**

1. **CatalogClient.tsx:**
   - Добавлен debounce 200ms для `loadVotes`
   - Использован `startTransition` для `setUserVotes`
   - Добавлена проверка `if (votesString !== currentVotesString)` для предотвращения ненужных обновлений
   - Использован `useRef` для `prevVotesRef` и `debounceTimerRef` вместо локальных переменных
   - Добавлен `isLoadingVotesRef` для защиты от повторных вызовов
   - Убрано дублирование инициализации

2. **EffectCard.tsx:**
   - Добавлена проверка `if (newVote && newVote !== userVote)` в `handleUpdate`
   - Использован `startTransition` для `setUserVote`
   - Добавлен `userVote` в dependency array для `useEffect`

#### H8: Ненужные re-renders в `EffectPageClient.tsx` из-за `setVotes(prev => ({ ...prev }))`
**Статус:** CONFIRMED
**Доказательства из логов:**
- `setVotes` вызывался даже когда значения не менялись
- `startTransition` выполнялся очень быстро (0-0.1ms), но вызывался часто

**Исправление:**
- Модифицирован `setVotes` для обновления только при реальном изменении: `prev.for !== newVotes.for || prev.against !== newVotes.against`
- Добавлена инструментация для отслеживания длительности `startTransition`

### Дополнительные исправления

#### `updateUnvotedEffects` debounce/throttle
**Проблема:**
- `updateUnvotedEffects` вызывался слишком часто (каждые 500-1200ms)
- Debounce не работал из-за локальных переменных в `useEffect`

**Исправления:**
- Увеличен debounce с 2s до 5s
- Добавлен throttle 10 секунд через `lastUpdateUnvotedEffectsTimeRef`
- Использован `useRef` для `updateUnvotedEffectsDebounceRef` и `lastUpdateUnvotedEffectsTimeRef`
- Убраны `requestIdleCallback` и `setTimeout(..., 0)` fallbacks
- `lastUpdateUnvotedEffectsTimeRef.current` обновляется сразу при установке debounce таймера

## Текущее состояние

### Что исправлено:
1. ✅ Debounce для `checkStatus` увеличен до 3 секунд
2. ✅ Debounce для `updateUnvotedEffects` увеличен до 5 секунд с throttle 10 секунд
3. ✅ Добавлен `startTransition` для неблокирующих обновлений состояния
4. ✅ Исправлены каскадные re-renders в `CatalogClient.tsx` и `EffectCard.tsx`
5. ✅ Исправлены ненужные re-renders в `EffectPageClient.tsx`
6. ✅ Добавлена защита от повторных вызовов `loadVotes` через `isLoadingVotesRef`

### Что осталось проблемой:
1. ❌ **БАГ НЕ УСТРАНЕН** - зависание UI все еще происходит
2. ❌ `loadVotes` все еще вызывается дважды в некоторых случаях (строки 64-65, 571-572 в логах)
3. ❌ Возможны другие источники блокировки UI, которые еще не обнаружены

### Инструментация

Добавлена обширная инструментация для отслеживания:
- `handleVote` - начало, блокировка, завершение, длительность
- `saveVote` - начало, завершение, длительность, активные запросы
- `checkStatus` - начало, блокировка, завершение, длительность
- `updateUnvotedEffects` - начало, завершение, длительность
- `loadVotes` - начало, завершение, длительность, обновление состояния
- `votesStore.set` - начало, завершение, длительность
- `startTransition` - завершение, длительность
- `localStorage SET` - длительность

### Следующие шаги

1. **Продолжить анализ логов** после последних исправлений
2. **Проверить другие источники блокировки:**
   - Framer Motion анимации
   - Другие event listeners
   - Другие `useEffect` хуки
   - Другие компоненты, которые могут вызывать re-renders
3. **Рассмотреть использование React DevTools Profiler** для выявления узких мест
4. **Проверить производительность `JSON.stringify`** при больших объемах данных
5. **Рассмотреть использование Web Workers** для тяжелых операций

## Файлы с изменениями

1. `components/EffectPageClient.tsx` - исправлены ненужные re-renders, добавлена инструментация
2. `lib/context/RealityContext.tsx` - увеличен debounce, добавлен `startTransition`
3. `app/catalog/CatalogClient.tsx` - исправлены каскадные re-renders, добавлена защита от повторных вызовов
4. `components/EffectCard.tsx` - исправлены каскадные re-renders, добавлен `startTransition`
5. `lib/votes-store.ts` - добавлена инструментация
6. `app/actions/votes.ts` - добавлена инструментация для отслеживания активных запросов

## Метрики производительности

Из логов видно:
- `saveVote` занимает ~1400-2000ms (нормально для серверных запросов)
- `checkStatus` занимает ~435-744ms (улучшено с debounce)
- `loadVotes` занимает ~122-389ms (может быть проблемой при частых вызовах)
- `startTransition` занимает 0-0.1ms (не блокирует)
- `localStorage SET` занимает ~0.3-0.5ms (не блокирует)

## Выводы

Несмотря на множество исправлений, проблема зависания UI все еще воспроизводится. Это указывает на то, что:
1. Проблема может быть в другом месте, не покрытом текущей инструментацией
2. Проблема может быть связана с комбинацией факторов, а не одним источником
3. Может потребоваться более глубокий анализ с использованием React DevTools Profiler
4. Возможно, проблема связана с браузером или системными ресурсами

**Требуется дальнейшая отладка.**

